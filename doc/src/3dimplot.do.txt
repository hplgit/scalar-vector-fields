========= Plotting in three dimensions =========

We will explain plotting in three dimensions using three different packages. As with plotting in chapter 5 we will go through matplotlib and scitools. 
Then we will go through Mayavi, which contain support for doing more advanced plotting operations. 

The three packages are different in many respects, but there are some common denominators. First of all, they all support rotation of a figure by holding the mouse cursor down. 
This functionality is often useful in order to get a better view of a surface. 

======= Matplotlib =======
The code below assumes that we have imported matplotlib as in chapter 5, i.e. that we use the prefix `plt` for matplotlib code:
!bc pycod
import matplotlib.pyplot as plt
!ec
Note that after each plot command you need to write `plt.show()` in order for the new plot to become visible.  

=== Curve plots in 3D ===
A parametrized curve can be plotted in 3D as follows
!bc pycod
t = np.linspace(0, 10*np.pi, 100)

fig = plt.figure()
ax = fig.gca(projection = '3d')
ax.plot(np.sin(t), np.cos(t), t)
!ec
The resulting plot is shown in Figure ref{parametrizedcurvematplotlib}
FIGURE:[images/parametrizedcurvematplotlib, height=400 width=600 frac=0.8] A parametrized curve plotted with matplotlib. label{parametrizedcurvematplotlib}

===== Simple surface plots =====
Let us start by plotting a surface $z=f(x,y)$ over an interval in the $xy$-plane. We first need to create a two-dimensional grid of values covering such an interval. A grid for the interval $[-4,4]\times[-2,2]$ 
can be created as follows.
!bc pycod
x = np.arange(-4, 4, 0.05, float)
y = np.arange(-2, 2, 0.05, float)
X, Y = np.meshgrid(x, y, sparse = False, indexing = 'ij')
!ec
This code sets `X` and `Y` to be coordinates so that all pairs $(x,y)$ constitute a grid covering the entire interval in the $xy$-plane.
Note the mysterious extra parameters to `meshgrid` here, which are needed in order for the coordinate axes to have the order we would expect in mathematics. 

Now that we have the grid coordinates, we need to create the corresponding function values. For the function $z=f(x,y)=xy\sin(xy)$, this can be done as follows  
!bc pycod
Z = X*Y*sin(X*Y)
!ec

The surface can now be plotted as follows:
!bc pycod
fig = plt.figure() 
ax = fig.gca(projection = '3d')
ax.plot_surface(X, Y, Z)
!ec
The result is shown in the left plot in Figure ref{plotmatplotlib}
FIGURE:[images/plotmatplotlib, height=400 width=600 frac=0.8] Two matplotlib surface plots. Simple plot (left), and a plot with colours (right). label{plotmatplotlib}

Coloring can be used to get a better view of surfaces. We can use the `cm`-module to obtain a color map which can be used to color the surface. 
!bc pycod
from matplotlib import cm
!ec
This can then be passed to the `plot_surface` function above as follows: 
!bc pycod
ax.plot_surface(X, Y, Z, cmap = cm.coolwarm)
!ec
The result is shown in the right plot in Figure ref{plotmatplotlib}. One can choose from a wide range of different color maps. 

===== Contour plots =====
In order to create a simple contour plot we can write the following
!bc pycod 
plt.contour(X, Y, Z)
!ec
The resulting plot is shown in Figure ref{simplecontourmatplotlib}
FIGURE:[images/simplecontourmatplotlib, height=400 width=600 frac=0.8] A simple matplotlib contour plot. label{simplecontourmatplotlib}

By adding a parameter we can specify how many contour levels to plot. The contour levels will be automatically chosen.
!bc pycod 
plt.contour(X, Y, Z, 10)
!ec
The result is shown in the upper left plot of Figure ref{advancedcontourmatplotlib}.
FIGURE:[images/advancedcontourmatplotlib, height=400 width=600 frac=0.8] Some other matplotlib contour plots: With 10 levels (upper left), with 10 levels in black (upper right), with specified levels (lower left), and with labeled levels (lower right). label{advancedcontourmatplotlib}

Normally the level curves are drawn with different colours. This is very useful on the display, but is less practical if you want to paste the figure into a black and white document. 
If you write
!bc pycod
plt.contour(X, Y, Z, 10, colors = 'k')
!ec
The result is shown in the upper right plot of Figure ref{advancedcontourmatplotlib}. All level curves will be drawn in black ('k' is the symbol for black). 

The automatically chosen levels above may not be the most interesting level curves, or may not be the levels we are interested in. We can specify which levels to include in the contour plot as follows. 
!bc pycod
levels = [0.1, 0.2, 0.3, 0.4]
plt.contour(X, Y, Z, levels = levels)
!ec
The result is shown in the lower left plot of Figure ref{advancedcontourmatplotlib}

The levels in a contour plot are not labeled with the corresponding values by default. To include a default kind of labeling of the levels, one can call the `clabel` function.
!bc pycod
cs = plt.contour(X, Y, Z)
plt.clabel(cs)
!ec
The result is shown in the lower right plot in Figure ref{advancedcontourmatplotlib}

===== Plotting vector fields =====
Let us attempt to plot the vector field 
$${\bf v} = \left( x^2 + 2y - \frac{1}{2} xy \right){\bf i}  - 3y{\bf j}.$$
If we want to plot this over $[-5,5]$, with $0.5$ distance between the vectors, we first need to create a two-dimensional grid as follows. 
!bc pycod 
t = np.linspace(-5, 5, 11)
x, y = np.meshgrid(t, t, sparse = False, indexing = 'ij')
vx = x**2 + 2*y - .5*x*y
vy = -3*y
!ec
The following code 
!bc pycod
plt.quiver(x, y, vx, vy, angles = 'xy', scale_units = 'xy', color = 'b')
!ec
plots the vector field. 
The two first parameters specify the $x$- and $y$-components of the points where vectors are to be drawn, and the next two parameters the actual components of the vectors.
The result is shown in the left plot in Figure ref{quivermatplotlib}
FIGURE:[images/quivermatplotlib, height=400 width=600 frac=0.8] A vector field plotted with matplotlib (left), and contours together with the gradients (right). label{quivermatplotlib}

The parameters `angles` and `scale_units` say that the vector field should be drawn as a gradient field, i.e. that the length of the vectors coincide with that of the vector ${\bf v}$. 
`color` indicates the colour to be used for the vectors (here blue). 
Often the vectors need to be scaled in order for them not to collide in the plot (alternatively one can have some more distance between the points in the arrays `x` and `y`. 
This can be done manually by using the `scale` parameter. Increasing this results in shorter vectors. 
Matplotlib will attempt to scale the plot automatically if the `scale` parameter is not set, in order to try to avoid that the vectors collide.

Let us round off by considering an example where we plot the contour lines of a function together with the gradient field of that function. 
The gradients are orthogonal to the contour lines, so let us see if we can observe this in our plot. As our function we will use 
$$h = \frac{h_0}{1+ \frac{x^2+y^2}{R^2}}.$$
This formula describes the height of an isolated mountain, where $h$ is the height above sea level, $h_0$ is the height at the top of the mountain, and $R$ describes the radius of the mountain. 
we will measure $h$ and $h_0$ in meters, and $R$ in kilometers. Prior to the code below we have set $h_0=2277$ and $R=4$. 
We first define a grid for the area closer to the mountain top than 10km in any direction.
!bc pycod
tt = np.linspace(-10., 10., 11)
xx, yy = np.meshgrid(tt, tt)       
hh = h0/(1+(xx**2 + yy**2)/(R**2))
!ec
We then compute the gradient using the built-in function `gradient` in `numpy`. 
!bc pycod
dhx, dhy = np.gradient(hh)         # Beregn gradientvektoren (dh/dx,dh/dy)
!ec
Finally we plot the vector field together with the contour lines in the same plot as follows. 
!bc pycod
plt.quiver(xx, yy, dhy, dhx, color = 'r', angles = 'xy')               

t = np.linspace(-10.,10.,21)
x, y = np.meshgrid(t, t)           
h = h0/(1+(x**2+y**2)/(R**2)) 
plt.hold('on')
plt.contour(x, y, h)
!ec
Here we have created a new grid which is finer, for plotting the surface. The result is shown in the right plot in Figure ref{quivermatplotlib}.
Note that in the call to `quiver` the vector components `dhy` and `dhx` were reversed. This seems to be an error in `matplotlib`.

======= Scitools =======
The code below assumes that we have imported scitools as in chapter 5: 
!bc pycod
from scitools.easyviz import *
!ec

=== Curve plots in 3D ===
TODO

===== Simple surface plots =====
Scitools has the function `ndgrid` which, just as `meshgrid`, can be used to create grids of all possible $(x,y)$-coordinate pairs from given one-dimensional coordinates.
One can simply replace the call to `meshgrid` above with  
!bc pycod
X, Y = ndgrid(x, y)
!ec
`ndgrid` is more flexible than `meshgrid` in the sense that it can be used to make three-dimensional grids also. 

The surface can now be plotted simply by writing `mesh(X, Y, Z)`, so that this part of the code is shorter than the three lines needed with matplotlib.
The result is shown in the left plot in Figure ref{plotscitools}.
FIGURE:[images/plotscitools, height=400 width=600 frac=0.8] Two scitools surface plots. Simple plot (left), and a plot with colours (right). label{plotscitools}

We can write `surf(X, Y, Z)` instead of `mesh(X, Y, Z)` to get a graph where the surface elements have been coloured. 
The result is shown in the right plot in Figure ref{plotscitools}. One can choose from a wide range of different color maps. 

===== Contour plots =====
In order to create a simple contour plot we can write the following
!bc pycod 
contour(X, Y, Z)
!ec
The resulting plot is shown in Figure ref{simplecontourscitools}
FIGURE:[images/simplecontourscitools, height=400 width=600 frac=0.8] A simple scitools contour plot. label{simplecontourscitools}

By adding a parameter we can specify how many contour levels to plot. The contour levels will be automatically chosen.
!bc pycod
contour(X, Y, Z, 10)
!ec
The result is shown in the upper left plot in Figure ref{advancedcontourscitools}.
FIGURE:[images/advancedcontourscitools, height=400 width=600 frac=0.8] Some other scitools contour plots: With 10 levels (upper left), with 10 levels in black (upper right), with specified levels (lower left), and with labeled levels (lower right). label{advancedcontourscitools}

Normally the level curves are drawn with different colours. This is very useful on the display, but is less practical if you want to paste the figure into a black and white document. If you write
!bc pycod
contour(X, Y, Z, 10, 'k')
!ec
all level curves will be drawn in black ('k' is the symbol for black). 
The result is shown in the upper right plot in Figure ref{advancedcontourscitools}.

The automatically chosen levels above may not be the most interesting level curves, or may not be the levels we are interested in. We can specify which levels to include in the contour plot as follows. 
!bc pycod
levels = [0.1, 0.2, 0.3, 0.4]
contour(X, Y, Z, levels = levels)
!ec
The result is shown in the lower left plot in Figure ref{advancedcontourscitools}.

The levels in a contour plot are not labeled with the corresponding values by default. To include a default kind of labeling of the levels, one can use a parameter called `clabels`.
!bc pycod
contour(X, Y, Z, clabels = 'on')
!ec
The result is shown in the lower right plot in Figure ref{advancedcontourscitools}.

===== Plotting vector fields =====
Let ur return to the vector field
$${\bf v} = \left( x^2 + 2y - \frac{1}{2} xy \right){\bf i}  - 3y{\bf j},$$
and let us reuse the code above to produce the vectors in the vector field. With scitools one can instead write
!bc pycod
quiver(x, y, vx, vy, 200, 'b')
!ec
##TODO: I need to consult the documentation here
to plot the vector field. The two last parameters represent scaling and color. The resulting plot is shown in Figure ref{quiverscitools}
FIGURE:[images/quiverscitools, height=400 width=600 frac=0.8] A vector field plotted with scitools (left), and contours together with the gradients (right). label{quiverscitools}

Let us round off by considering again the previous example of contour/gradient plot. 
We again define a grid for the area closer to the mountain top than 10km in any direction, but this time we use `ndgrid` in `scitools`.
!bc pycod
tt = linspace(-10., 10., 11)
xx, yy = ndgrid(tt, tt)      
hh = h0/(1 + (xx**2 + yy**2)/(R**2)) 
!ec
and we compute the gradient as before. 
Finally we plot the vector field together with the contour lines in the same plot as follows. 
!bc pycod
quiver(xx, yy, dhx, dhy, 0, 'r')        
       
t = linspace(-10., 10., 21)
x,y = ndgrid(t,t)             
h = h0/(1+(x**2+y**2)/(R**2)) 
hold('on')     
contour(x, y, h, daspectmode = 'equal') 
!ec
The result is shown in the right plot in Figure ref{quiverscitools}.







======= Mayavi =======
Mayavi is an advanced, free, easy to use, scientific data visualizer, with an emphasis on 3D visualization. 
It is written in Python, and uses the Visualization Toolkit (VTK) for the graphics. 
It is cross platform and should run on any platform where both Python and VTK are available (this includes Mac OSX and windows).
To obtain a full environment for Mayavi, which contains Python , VTK, and all its dependencies, you can install Canopy. 
This gives you access to install not only Mayavi, but also a whole list of packages from what is called a package index.
While Mayavi will work right out of the box with Canopy, you can also install all components by hand (more on this). 

We will only consider the Mayavi-functionality for simple plotting, such as the functionality we considered for matplotlib and scitools. 
The `mayavi.mlab` module provides a simple interface to such plotting, with an emphasis on 3D visualization. 
The following code will assume that we have imported everything from this module. 

===== The basics =====
We first need to cover some of the `mlab` basics. Not that much of this is similar to the bascis found in matplotlib, and we will try to focus mainly on the differences. 

The plotting commands you do in mlab will go to the current figure, also called a scene. This means that several plot commands will be shown together. 
You can work with several figure instances simultaneously. A figure can be accessed in three different ways:
o as a `Figure` object representing it,
o by a name representing it, 
o by a number representing the index of the plot
When either a Figure object, a name or an integer is supplied as parameter to the function `figure()`, `mlab` sets the current figure to be that particular Figure object, 
or the Figure object with that name or index. If no figure existed with the given name/index, a new figure object will be created with that name/index, and set as the current figure.  

In the same way, the function `close()` closes a figure with the given handle, name, or index. 
To clear (not close) the current figure before the next plot, we can run the command `clf()`. 
The function `gcf()` returns the current figure object. You will need to call this in order to get the object where you can set some the figure properties, 
such as the foreground or background colour (the foreground colour is used for text and labels included in the plot). This can also be done directly by writing
!bc pycod
figure(fgcolor = (.0, .0, .0), bgcolor = (1.0, 1.0, 1.0))
!ec
Here colours are represented as RGB-values, where the components are floating points between zero and one. In the above code the foreground and background colour 
for the current figure is set to black and white, respectively.

Many of the other functions are also similar to what we are used to.
* `savefig(filename)` saves the current figure to file. The type of the file (png, jpeg, etc) is deduced fom the file extension  
* `show()` makes the current figure visible (it may be that the environment does this by itself).
* `title` to decorate the current figure  with a title.
* `axes` for creating axes with labels and given colors, we can use the function   axes(xlabel = 'x', ylabel = 'y')

The following code examplifies all the above in one plot. 
!bc pycod
clf() # Clear
# Create figure with white background, black foreground
figure(fgcolor = (.0, .0, .0), bgcolor = (1.0, 1.0, 1.0)) 
... Create and plot your figure
title('My first plot')
axes(xlabel = 'x', ylabel = 'y', zlabel = 'z', nb_labels = 5, color = (0., 0., 0.))
show()
savefig('plot.png')
!ec

=== Curve plots in 3D ===
A parametrized curve can be plotted in 3D by replacing the plotting command above as follows
!bc pycod
t = np.linspace(0, 10*np.pi, 100)

plot3d(np.sin(t), np.cos(t), t)
!ec
while keeping the rest of the code above for decorating the axes. The resulting plot is shown in Figure ref{parametrizedcurvemayavi}. 
FIGURE:[images/parametrizedcurvemayavi, height=400 width=600 frac=0.8] A parametrized curve plotted with Mayavi. label{parametrizedcurvemayavi}

===== Simple surface plots and subplots =====
The surface $z=f(x,y)=xy\sin(xy)$ can now be plotted by replacing the plotting command above with
!bc pycod
mesh(X, Y, Z)
!ec
The result is shown in the left plot in Figure ref{plotmayavi}.
FIGURE:[images/plotmayavi, height=400 width=600 frac=0.8] Two Mayavi surface plots. Using `mesh` (left), and using `surf` (right). label{plotmayavi}
For coloring the surface we can use the similar `surf` as follows. 
!bc pycod
surf(X, Y, Z)
!ec
The result is shown in the right plot in Figure ref{plotmayavi}. 

The two plots in figure ref{plotmayavi} were created as separate figures. One can also create them as subplots within one figure, so that one figure is generated with several subplots. Consider the following code.
!bc pycod
surf1 = mesh(X - 10, Y, Z, color = (.5, .5, .5))
cat1_extent = (-14, -6, -2, 3, 0, 5)
outline(surf1, extent=cat1_extent)

surf2 = mesh(X, Y, Z, colormap = 'Accent')
cat2_extent = (-4, 4, -2, 3, 0, 5)
outline(surf2, extent=cat2_extent)

surf3 = mesh(X + 10, Y, Z, colormap = 'prism')
cat3_extent = (6, 14, -2, 3, 0, 5)
outline(surf3, extent=cat3_extent, color = (0.5, 0.5, 0.5))
!ec
The result is shown in the left plot in Figure ref{subplot}.
FIGURE:[images/subplot, height=400 width=600 frac=0.8] A plot with three subplots created with mayavi, consisting of the same surface drawn with different color maps. label{subplot}

Here three separate `mesh` commands are run, each producing a new plot in the current figure. The $x$-coordinates are seen to be `X - 10`, `X`, and `X + 10`, so that the three plotting areas do not overlap. 
The handles to the three plots are stored in the variables `surf1`, `surf2`, and `surf3`, and bounding boxes `cat1_extent`, `cat2_extent`, and `cat3_extent` are defined, which contain coordinates which bound the three different plots.   
The function `outline` finally draws the corresponding box for the plot in question. We have dropped the axes and the title here. 

Note that the surfaces in Figure ref{subplot} are drawn with different colors. This is due to the `colormap` and `color` attributes in the call to `mesh`, which adjusts the colors when the surface is drawn. The `color` attribute, which we see also can be used as a 
parameter to `outline`, adjusts the surface so that it is colored with small variations from the provided base-color. 
One can choose from a wide range of different color maps. 


===== Contour plots =====
In order to create a simple contour plot we can write the following
!bc pycod 
contour_surf(X, Y, Z)
!ec
The result is shown in the upper left plot in Figure ref{advancedcontourmayavi}. 
FIGURE:[images/advancedcontourmayavi, height=400 width=600 frac=0.8] Some mayavi contour plots: Simple plot (upper left), with 10 levels (upper right), with 10 levels in black (lower left), and with specified levels (lower right). label{advancedcontourmayavi}

By adding a parameter we can specify how many contour levels to plot. The contour levels will be automatically chosen by the application.
!bc pycod 
contour_surf(X, Y, Z, contours = 10)
!ec
The result is shown in the upper right plot of Figure ref{advancedcontourmayavi}.


Normally the level curves are drawn with different colours. This is very useful on the display, but is less practical if you want to paste the figure into a black and white document. 
If you write
!bc pycod
contour_surf(X, Y, Z, contours = 10, color = (0., 0., 0.))
!ec
The result is shown in the lower left plot of Figure ref{advancedcontourmayavi}. All level curves will be drawn in black, as described by the components in the color `(0., 0., 0.)`. 

The automatically chosen levels above may not be the most interesting level curves, or may not be the levels we are interested in. We can specify which levels to include in the contour plot as follows. 
!bc pycod
levels = [0.1, 0.2, 0.3, 0.4]
contour_surf(X, Y, Z, contours = levels)
!ec
The result is shown in the lower right plot of Figure ref{advancedcontourmayavi}

===== Plotting vector fields in 3D =====
Mayavis functionality for plotting vector fields is primarily intended for 3D also. As an example, let us attempt to plot a gravitational field. 
Newtons law of gravitation says that the gravitational force is proportional to 
$$-{\bf r}/|{\bf r}|^3 = -( x,y,z)/\sqrt{x^2+y^2+z^2}^3,$$
where ${\bf r}=(x,y,z)$ is the position vector. Let us attempt to plot this vector field. 
We need a three-dimensional grid, so that `meshgrid` will not work. We can either use `ndgrid` from `scitools`, or `mgrid` from `numpy` as follows
If we want to plot this over $[-5,5]$, with $0.5$ distance between the vectors, we first need to create a two-dimensional grid as follows. 
!bc pycod 
x, y, z = np.mgrid[.5:2:.2, .5:2:.2, .5:2:.2]
r3 = np.sqrt(x**2 + y**2 + z**2)**3
vx = -x/r3
vy = -y/r3
vz = -z/r3
!ec
The cube of the distance (`r3`) has here been computed once, since all three components are divided by this. 
Also we compute the vector field for a section in the first octant only, where all three components are between $0.5$ and $2$, and we do not make the grid too dense, so that individual vectors have smaller chance of colliding. 
The vector field can now be vizualized as follows. 
!bc pycod
figure(fgcolor = (.0, .0, .0), bgcolor = (1.0, 1.0, 1.0)) 
quiver3d(x, y, z, -x/r3, -y/r3, -z/r3, \\
         mode = 'arrow', colormap = 'jet', scale_factor = .5)
axes(xlabel = 'x', ylabel = 'y', zlabel = 'z', \\
     nb_labels = 5, color = (0., 0., 0.))
!ec
The three first parameters to `quiver3d`, the function which actually plots the vector field, specify the $x$-, $y$-, and $z$-components of the points where vectors are to be drawn. 
The next three parameters are the actual components of the vectors.
To improve the visualization of the field, we have set some of the optional properties to `quiver3d`:
* The `mode` parameter ensures that the vectors are drawn as arrow. 
* The `colormap` parameter controls how the vectors are colored.
* The `scale_factor` parameter lets us manually scale the vector lengths, to ensure that they do not collide. 
In addition we have set a foreground and background color for the figure, and added axes as above. 
The resulting plot is shown in Figure ref{quivermayavi}. This shows some of the challenges in plotting vecto fiels in 3D dimensions. It may be challenging to create instructive plots, since vectors are drawn over an area in 3D rather than 2D. 
FIGURE:[images/quivermayavi, height=400 width=600 frac=0.8] A vector field plotted with mayavi. label{quivermayavi}

===== Animations =====
We have previously seen how to produce animations with maplotlib and scitools. 
With the function `animate` in `mlab` we can also create animations. 